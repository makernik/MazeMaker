/**
 * Maze Solver - BFS Pathfinder
 * 
 * Validates that a maze has exactly one solution using BFS (Breadth-First Search).
 * BFS guarantees finding the shortest path if one exists.
 * 
 * For a perfect maze (generated by Prim's), there is always exactly one path
 * between any two points, so we just need to verify a path exists.
 */

import { DIRECTIONS, DIRECTION_OFFSETS } from './grid.js';

/**
 * Solve a maze using BFS
 * 
 * @param {MazeGrid} grid - The maze grid to solve
 * @returns {object|null} Solution object with path, or null if unsolvable
 */
export function solveMaze(grid) {
  const { start, finish } = grid;
  
  // BFS queue: each entry is { row, col, path }
  const queue = [{
    row: start.row,
    col: start.col,
    path: [{ row: start.row, col: start.col }],
  }];
  
  // Track visited cells
  const visited = new Set();
  visited.add(`${start.row},${start.col}`);
  
  while (queue.length > 0) {
    const current = queue.shift();
    
    // Check if we reached the finish
    if (current.row === finish.row && current.col === finish.col) {
      return {
        path: current.path,
        length: current.path.length,
        solved: true,
      };
    }
    
    // Explore all directions
    for (const direction of Object.values(DIRECTIONS)) {
      // Check if we can move in this direction (no wall)
      const cell = grid.getCell(current.row, current.col);
      if (cell.hasWall(direction)) continue;
      
      // Get the neighbor position
      const [dRow, dCol] = DIRECTION_OFFSETS[direction];
      const newRow = current.row + dRow;
      const newCol = current.col + dCol;
      
      // Skip if out of bounds or already visited
      const key = `${newRow},${newCol}`;
      if (!grid.isValidPosition(newRow, newCol)) continue;
      if (visited.has(key)) continue;
      
      // Mark as visited and add to queue
      visited.add(key);
      queue.push({
        row: newRow,
        col: newCol,
        path: [...current.path, { row: newRow, col: newCol }],
      });
    }
  }
  
  // No path found
  return null;
}

/**
 * Validate that a maze is solvable
 * 
 * @param {MazeGrid} grid - The maze grid to validate
 * @returns {boolean} True if maze has a valid solution
 */
export function validateMaze(grid) {
  const solution = solveMaze(grid);
  return solution !== null && solution.solved;
}

/**
 * Check if a maze is a "perfect" maze (single solution)
 * 
 * For mazes generated by Prim's algorithm, this is guaranteed,
 * but this function provides an explicit verification.
 * 
 * A perfect maze has exactly one path between any two points,
 * which means all cells should be reachable from the start.
 * 
 * @param {MazeGrid} grid - The maze grid to check
 * @returns {object} Validation result with reachable cell count
 */
export function isPerfectMaze(grid) {
  const { start } = grid;
  const totalCells = grid.rows * grid.cols;
  
  // BFS to count reachable cells
  const visited = new Set();
  const queue = [{ row: start.row, col: start.col }];
  visited.add(`${start.row},${start.col}`);
  
  while (queue.length > 0) {
    const current = queue.shift();
    const cell = grid.getCell(current.row, current.col);
    
    for (const direction of Object.values(DIRECTIONS)) {
      if (cell.hasWall(direction)) continue;
      
      const [dRow, dCol] = DIRECTION_OFFSETS[direction];
      const newRow = current.row + dRow;
      const newCol = current.col + dCol;
      
      const key = `${newRow},${newCol}`;
      if (!grid.isValidPosition(newRow, newCol)) continue;
      if (visited.has(key)) continue;
      
      visited.add(key);
      queue.push({ row: newRow, col: newCol });
    }
  }
  
  const reachableCells = visited.size;
  const isPerfect = reachableCells === totalCells;
  
  return {
    isPerfect,
    reachableCells,
    totalCells,
    allCellsReachable: isPerfect,
  };
}

/**
 * Get solution path as an array of directions
 * Useful for debugging and visualization
 * 
 * @param {object[]} path - Array of {row, col} positions
 * @returns {string[]} Array of direction names
 */
export function pathToDirections(path) {
  if (!path || path.length < 2) return [];
  
  const directionNames = {
    [DIRECTIONS.TOP]: 'up',
    [DIRECTIONS.RIGHT]: 'right',
    [DIRECTIONS.BOTTOM]: 'down',
    [DIRECTIONS.LEFT]: 'left',
  };
  
  const directions = [];
  
  for (let i = 1; i < path.length; i++) {
    const prev = path[i - 1];
    const curr = path[i];
    
    const dRow = curr.row - prev.row;
    const dCol = curr.col - prev.col;
    
    let direction;
    if (dRow === -1) direction = DIRECTIONS.TOP;
    else if (dRow === 1) direction = DIRECTIONS.BOTTOM;
    else if (dCol === -1) direction = DIRECTIONS.LEFT;
    else if (dCol === 1) direction = DIRECTIONS.RIGHT;
    
    directions.push(directionNames[direction]);
  }
  
  return directions;
}
