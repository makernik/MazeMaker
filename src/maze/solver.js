/**
 * Maze Solver - BFS Pathfinder
 * 
 * Validates that a maze has exactly one solution using BFS (Breadth-First Search).
 * Supports both grid mazes and organic (graph) mazes via unified solveMaze(maze) / validateMaze(maze).
 */

import { DIRECTIONS, DIRECTION_OFFSETS } from './grid.js';

/**
 * Solve a maze (grid or organic). Accepts full maze object or grid.
 *
 * @param {object} mazeOrGrid - Maze object (with layout, grid or graph, start/finish) or MazeGrid
 * @returns {object|null} Solution: { path, length, solved }. Grid path is [{row,col}]; organic path is node ids.
 */
export function solveMaze(mazeOrGrid) {
  if (mazeOrGrid.layout === 'organic') {
    return solveMazeOrganic(mazeOrGrid.graph, mazeOrGrid.startId, mazeOrGrid.finishId);
  }
  const grid = mazeOrGrid.grid ?? mazeOrGrid;
  return solveMazeGrid(grid);
}

/**
 * BFS on grid maze.
 * @param {MazeGrid} grid
 * @returns {object|null}
 */
function solveMazeGrid(grid) {
  const { start, finish } = grid;

  const queue = [{
    row: start.row,
    col: start.col,
    path: [{ row: start.row, col: start.col }],
  }];
  const visited = new Set();
  visited.add(`${start.row},${start.col}`);

  while (queue.length > 0) {
    const current = queue.shift();
    if (current.row === finish.row && current.col === finish.col) {
      return { path: current.path, length: current.path.length, solved: true };
    }
    const cell = grid.getCell(current.row, current.col);
    for (const direction of Object.values(DIRECTIONS)) {
      if (cell.hasWall(direction)) continue;
      const [dRow, dCol] = DIRECTION_OFFSETS[direction];
      const newRow = current.row + dRow;
      const newCol = current.col + dCol;
      const key = `${newRow},${newCol}`;
      if (!grid.isValidPosition(newRow, newCol) || visited.has(key)) continue;
      visited.add(key);
      queue.push({
        row: newRow,
        col: newCol,
        path: [...current.path, { row: newRow, col: newCol }],
      });
    }
  }
  return null;
}

/**
 * BFS on organic graph: traverse only edges with no wall (passage).
 *
 * @param {OrganicGraph} graph
 * @param {number} startId
 * @param {number} finishId
 * @returns {object|null} { path: number[], length, solved }
 */
function solveMazeOrganic(graph, startId, finishId) {
  const queue = [{ id: startId, path: [startId] }];
  const visited = new Set([startId]);

  while (queue.length > 0) {
    const current = queue.shift();
    if (current.id === finishId) {
      return { path: current.path, length: current.path.length, solved: true };
    }
    for (const nid of graph.getNeighbors(current.id)) {
      if (graph.hasWall(current.id, nid) || visited.has(nid)) continue;
      visited.add(nid);
      queue.push({ id: nid, path: [...current.path, nid] });
    }
  }
  return null;
}

/**
 * Validate that a maze is solvable. Accepts full maze object or grid.
 *
 * @param {object} mazeOrGrid - Maze object or MazeGrid
 * @returns {boolean}
 */
export function validateMaze(mazeOrGrid) {
  const solution = solveMaze(mazeOrGrid);
  return solution !== null && solution.solved;
}

/**
 * Check if a maze is a "perfect" maze (single solution)
 * 
 * For mazes generated by Prim's algorithm, this is guaranteed,
 * but this function provides an explicit verification.
 * 
 * A perfect maze has exactly one path between any two points,
 * which means all cells should be reachable from the start.
 * 
 * @param {MazeGrid} grid - The maze grid to check
 * @returns {object} Validation result with reachable cell count
 */
export function isPerfectMaze(grid) {
  const { start } = grid;
  const totalCells = grid.rows * grid.cols;
  
  // BFS to count reachable cells
  const visited = new Set();
  const queue = [{ row: start.row, col: start.col }];
  visited.add(`${start.row},${start.col}`);
  
  while (queue.length > 0) {
    const current = queue.shift();
    const cell = grid.getCell(current.row, current.col);
    
    for (const direction of Object.values(DIRECTIONS)) {
      if (cell.hasWall(direction)) continue;
      
      const [dRow, dCol] = DIRECTION_OFFSETS[direction];
      const newRow = current.row + dRow;
      const newCol = current.col + dCol;
      
      const key = `${newRow},${newCol}`;
      if (!grid.isValidPosition(newRow, newCol)) continue;
      if (visited.has(key)) continue;
      
      visited.add(key);
      queue.push({ row: newRow, col: newCol });
    }
  }
  
  const reachableCells = visited.size;
  const isPerfect = reachableCells === totalCells;
  
  return {
    isPerfect,
    reachableCells,
    totalCells,
    allCellsReachable: isPerfect,
  };
}

/**
 * Get solution path as an array of directions
 * Useful for debugging and visualization
 * 
 * @param {object[]} path - Array of {row, col} positions
 * @returns {string[]} Array of direction names
 */
export function pathToDirections(path) {
  if (!path || path.length < 2) return [];
  
  const directionNames = {
    [DIRECTIONS.TOP]: 'up',
    [DIRECTIONS.RIGHT]: 'right',
    [DIRECTIONS.BOTTOM]: 'down',
    [DIRECTIONS.LEFT]: 'left',
  };
  
  const directions = [];
  
  for (let i = 1; i < path.length; i++) {
    const prev = path[i - 1];
    const curr = path[i];
    
    const dRow = curr.row - prev.row;
    const dCol = curr.col - prev.col;
    
    let direction;
    if (dRow === -1) direction = DIRECTIONS.TOP;
    else if (dRow === 1) direction = DIRECTIONS.BOTTOM;
    else if (dCol === -1) direction = DIRECTIONS.LEFT;
    else if (dCol === 1) direction = DIRECTIONS.RIGHT;
    
    directions.push(directionNames[direction]);
  }
  
  return directions;
}
